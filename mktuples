#!/usr/bin/perl
use strict;
use Generator;
use Getopt::Long;

my $n = 1;
my $namespace = "Mono.Rocks";
my $output = "Tuples.cs";
my $help = undef;

GetOptions (
	"n|count=i",    \$n,
	"o|output=s",   \$output,
	"namespace=s",  \$namespace,
	"h|?|help",     \$help
);

if ($help) {
	print <<EOF;
$0 [-n N] [-o FILE] [-h]
Create a C# file containing N tuple types.

Options:
  -n, --count=N       The number of types to generate.  Defaults is 1.
  -o, --output=FILE   The file to create.  Default is `Tuples.cs'.
      --namespace=NS  Place the types within the namespace NS.
                        Default is `Mono.Rocks'.
  -h, -?, --help      Show this message and exit.
EOF
	exit 0;
}

if ($n < 1) {
	print STDERR "error: n must be >= 1, was $n\n";
	exit 1;
}

my $handle = *STDOUT;

my $g = Generator->new ($handle);

my $header = <<EOF;
//
// $output: Tuple types.
//
// GENERATED CODE: DO NOT EDIT.
//
// To regenerate this code, execute: $0 -n $n -o $output
//
// Copyright (c) 2008 Novell, Inc. (http://www.novell.com)
EOF
$g->Write ($header);
$g->WriteLicense ();
$g->Write ("using System;\n");
$g->Write ("using System.Collections;\n");
$g->Write ("using System.Collections.Generic;\n");
$g->Write ("using System.Reflection;\n");
$g->Write ("using System.Text;\n\n");

$g->Namespace ($namespace, sub {
	create_tuple ($g, $n);

	create_funcs ($g, $n);

	for (my $i = 1; $i <= $n; ++$i) {
		create_type ($g, $i);
	}

});

sub create_tuple {
	my ($g, $n) = @_;

	$g->Type ( "\npublic abstract partial class Tuple", sub {
		$g->Write ("\npublic static readonly int MaxValues = $n;\n");

		create_tuple_method ($g, 1);

		for (my $i = 2; $i <= $n; ++$i) {
			create_tuple_method ($g, $i);
		}
	});

}

sub create_funcs {
	my ($g, $n) = @_;
	if ($n > $g->MaxSystemFuncs) {
		for (my $i = $g->MaxSystemFuncs+1; $i <= $n; ++$i) {
			$g->Write ("\npublic delegate TResult RocksFunc<");
			$g->TypeParameterList ($i);
			$g->Write (", TResult> (");
			$g->MethodParameterList ($i);
			$g->Write (");");
		}
		$g->Write ("\n");
	}
}

sub create_tuple_method {
	my ($g, $n) = @_;

	$g->Method (
		sub { $g->Write ("\npublic static Tuple<")->TypeParameterList ($n)->Write (">"); },
		sub { $g->Write ("\n\tCreate<")->TypeParameterList ($n)->Write (">"); },
		sub { $g->MethodParameterList ($n); },
		sub {
			$g->Write ("return new Tuple<")->TypeParameterList ($n)->Write ("> (")
				->ValueList ($n)->Write (");\n");
		}
	);
}

sub create_type {
	my ($g, $n) = @_;

	$g->Type (
		sub { 
			$g->Write ("\npublic class Tuple<")->TypeParameterList ($n)->Write (">\n")
				->Write ("\t: Tuple, IEquatable<Tuple<")->TypeParameterList ($n)->Write (">>\n");
		},
		sub {
			for (my $i = 1; $i <= $n; ++$i) {
				$g->Write ("private readonly ")->TypeParameter ($n, $i)->Write (" ")
					->Value ($n, $i)->Write (";\n");
			}

			$g->Method (
				"\npublic ",
				"Tuple",
				sub { $g->MethodParameterList ($n); },
				sub {
					for (my $i = 1; $i <= $n; ++$i) {
						$g->Write ("this.")->Value ($n, $i)->Write (" = ")->Value ($n, $i)->Write (";\n");
					}
			});

			$g->Write ("\n");

			for (my $i = 1; $i <= $n; ++$i) {
				$g->Write ("public ")->TypeParameter ($n, $i)
					->Write (" _$i {get{return ")->Value ($n, $i)->Write (";}}\n");
			}

			$g->Write ("\npublic override int Count {\n\tget {return $n;}\n}\n");
			$g->Method ( "\npublic override int ", "GetHashCode", "", sub {
					$g->Write ("int hc = 0;\n");
					for (my $i = 1; $i <= $n; ++$i) {
						$g->Write ("hc ^= _$i.GetHashCode ();\n");
					}
					$g->Write ("return hc;\n");
			});
			$g->Method ("\npublic override bool ", "Equals", "object obj", sub {
				$g->Write ("Tuple<")->TypeParameterList ($n)->Write ("> t = obj as ")
					->Write ("Tuple<")->TypeParameterList ($n)->Write (">;\n")
					->Write ("if (t == null)\n")
					->Write ("\treturn false;\n")
					->Write ("return Equals (t);\n");
			});
			$g->Method ("\npublic bool ", "Equals", 
				sub { $g->Write ("Tuple<")->TypeParameterList ($n)->Write ("> obj"); },
				sub {
					$g->Write ("return EqualityComparer<")->TypeParameter ($n, 1)
						->Write (">.Default.Equals (_1, obj._1)\n");
					for (my $i = 2; $i <= $n; ++$i) {
						$g->Write ("\t&& EqualityComparer<")->TypeParameter ($n, $i)
							->Write (">.Default.Equals (_$i, obj._$i)\n");
					}
					$g->Write ("\t;\n");
			});
			$g->Write ("\npublic override object this [int index] {\n")
				->Write ("\tget {\n")
				->Write ("\t\tswitch (index) {\n");
			for (my $i = 1; $i <= $n; ++$i) {
				$g->Write ("\t\t\tcase ", $i-1, ": return _$i;\n");
			}
			$g->Write ("\t\t}\n");
			$g->Write ("\t\treturn base [index];\n");
			$g->Write ("\t}\n");
			$g->Write ("}\n");

			$g->Method ("\npublic TResult ", "Aggregate<TResult>", 
				sub { $g->Func ($n)->Write ("<")->TypeParameterList ($n)->Write (", TResult> func"); },
				sub { $g->Write ("return func (")->ValueList ($n)->Write (");\n"); }
			);

			$g->Method ("\nprotected override void ", "AppendValue", "StringBuilder buf", sub {
				$g->Write ("buf.Append (_1);\n");
				for (my $i = 2; $i <= $n; ++$i) {
					$g->Write ("buf.Append (\", \");\n");
					$g->Write ("buf.Append (_$i);\n");
				}
			});
	});
}

