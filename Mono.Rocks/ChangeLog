2008-07-25  Jonathan Pryor  <jpryor@novell.com>

	* Tuple.cs, Tuples.cs: Added; implementation of Tuples and related types 
	  of arity up to 4.
	* KeyValuePair.cs: Add a .ToTuple() extension method.

2008-07-25  Jonathan Pryor  <jpryor@novell.com>

	* KeyValuePair.cs: Add a new KeyValuePair class to simplify the creation of
	  KeyValuePair<TKey, TValue> instances (more type inferencing!);
	  KeyValuePair.Create(K,V) creates a KeyValuePair<K,V>, while
	  KeyValuePair.Just(K,V) creates a Nullable<KeyValuePair<K,V>> (the name
	  "Just" comes from the Haskell Maybe type).
	* Sequence.cs: Add more Haskell-inspired methods:
	  - (unfoldr) .GenerateReverse<S,R>(S,Func<S,KeyValuePair<R,S>?>) -> IEnumerable<R>

2008-07-24  Jonathan Pryor  <jpryor@novell.com>

	* Check.cs: Add Check.Func().
	* IEnumerable.cs: Add more Haskell-inspired extension methods:
	  - (cycle) .Cycle<S>(IEnumerable<S>)
	* Sequence.cs: Added; more Haskell-inspired methods that don't yet make
	  sense as extension methods:
	  - (iterate) Iterate<TSource>(TSource, Func<TSource, TSource>)
	  - (repeat) Repeat<TSource>(TSource)

2008-07-11  Jonathan Pryor  <jpryor@novell.com>

	* IEnumerable.cs: Add .Convert(), which is a simpler interface for
	  scanf(3)-like behavior than .ApplyPairs(), and also more limiting.
	  Allows usage such as `"w 1 1.5".Words().Convert(out a, out b, out c)`
	  where the default TypeConverter is used to perform the type
	  conversion based on the target type, so 
	    DateTime d; "1977-01-1".Scan (out d);
	  properly converts the string to a DateTime instance.

2008-07-11  Jonathan Pryor  <jpryor@novell.com>

	* IEnumerable.cs: Add .ApplyPairs(), which is a pair-wise application of
	  elements from an IEnumerable<T> to correspondingly indexed elements
	  from an Action<T> array.  The scenario is in the spirit of scanf(3),
	  where of sequence of values must be "scanned", converted, and stored
	  into a series of variables.  .ApplyPairs() uses delegates for the
	  conversion and storage portion.  So:
	    char buf[10]; int n; double d;
	    sscanf("w 1 1.5", "%s %d %lf", buf, &n, &d);
	  would become:
	    string s; int n; double d;
	    "w 1 1.5".Words().ApplyPairs (
	      v => s = v, 
	      v => n = int.Parse (v), 
	      v => d = double.Parse (v)
	    ).Apply ();
	  In this fashion the actual parsing of the input string is kept
	  separate from conversion & storage, so any routine to split a string
	  into a sequence could be used (e.g. string.Split(), regex, etc.).

2008-06-25  Jonathan Pryor  <jpryor@novell.com>

	* IEnumerable.cs: 
	  - Add additional Implode() overloads, so that we can efficiently 
	    perform per-node selection/modification.  In particular, to
	    convert {"foo","bar"} into the string "'foo', 'bar'" (helpful for
	    SQL and debugging), we previously could do:
	      list.Select(e => "'" + e + "'").Implode (", ")
	    Which, while it works, has bad memory implications (extraneous
	    temporary strings).  Instead, we can now do:
	      list.Implode(", ", (b, e) => {b.Append("'").Append(e).Append("'");});
	    which maintains the StringBuilder internally, so no garbage
	    strings need be created.
	  - Change .SelectAggregated() and .SelectReverseAggregated() to drop
	    the `resultSelector` argument and instead return a
	    KeyValuePair<TAccumulate, List<TResult>> directly.  This
	    simplifies usage, removing a method parameter.
	* KeyValuePair.cs: Added; extension methods for KeyValuePair<TKey, TValue>,
	  in particular .Aggregate() so that we can easily chain the KeyValuePair`2
	  return value of .SelectAggregated()/.SelectReverseAggregated() for test
	  purposes.

2008-06-23  Jonathan Pryor  <jpryor@novell.com>

	* IEnumerable.cs: Add more Haskell-inspired extension methods:
	  - (mapAccumL) .SelectAggregated<S,A,AR,R>(A,Func<A,S,KVP<A,AR>>,Func<A,List<AR>,R>)
	  - (mapAccumR) .SelectReverseAggregated<S,A,AR,R>(A,Func<A,S,KVP<A,AR>,Func<A,List<AR>,R>)

2008-06-23  Jonathan Pryor  <jpryor@novell.com>

	* IEnumerable.cs: Add OrderByNatural() to allow easy "natural" ordering,
	  and SortNatural() to allow easy "natural" sorting.
	* NaturalStringComparer.cs: Added; IComparer<string> implementation 
	  which sorts strings "naturaly", i.e. sorting embedded numbers 
	  numerically instead of lexicographically.  This allows "1 2 10" to be 
	  sorted as "1 2 10" instead of as "1 10 2" (lexicographic comparison).

2008-06-19  Jonathan Pryor  <jpryor@novell.com>

	* Check.cs: Remove Source() and rename SourceAndFunc() to
	  SelfAndFunc().
	* IEnumerable.cs, String.cs, TextReader.cs: s/source/self/g.

2008-06-19  Jonathan Pryor  <jpryor@novell.com>

	* String.cs: Remove EachLine(), re-implement Lines() in terms of
	  TextReaderRocks.Lines(), and add a Words() extension method.
	* TextReader.cs: Added; extension methods Lines() and Words() for
	  TextReader instances.

2008-06-18  Jonathan Pryor  <jpryor@novell.com>

	* Int32.cs: Remove [Obsolete] methods.

2008-06-18  Jonathan Pryor  <jpryor@novell.com>

	* IEnumerable.cs: Rename AggregateWithHistory() to AggregateHistory()
	  and AggregateReverseWithHistory() to AggregateReverseHistory().

2008-06-18  Jonathan Pryor  <jpryor@novell.com>

	* IEnumerable.cs: 
	  - Change semantics of AggregateReverse(), AggregateWithHistory(), 
	    AggregateReverseWithHistory() so that an empty sequence is invalid 
	    only if a seed value isn't provided.  This matches the semantics 
	    of Aggregate().  
	  - Fix AggregateWithHistory() and AggregateReverseWithHistory() so that
	    parameter-checking exceptions are emitted immediately, not delayed.
	  - Fix *WithHistory() so they don't return too many elements.
	  - Parameter name cleanup/consistency.

2008-06-18  Jonathan Pryor  <jpryor@novell.com>

	* IEnumerable.cs: Rename Join() to Implode(), as .NET already provides a
	  Join() function with completely different semantics (SQL JOIN, i.e. list
	  intersection), so this should remove ambiguity/confusion.

2008-06-17  Jonathan Pryor  <jpryor@novell.com>

	* Check.cs: Add Check.Source().
	* IEnumerable.cs: Add error checking to .Sort() methods.  Add
	  .SelectFromEach() overloads to accept up to 4 lists (i.e. Haskell zip, 
	  zip3, and zip4 are now supported).  Change semantics of .SelectFromEach()
	  to accept empty lists (previously this would throw an
	  InvalidOperationException, but Haskell permits empty lists so why not?).

2008-06-17  Jonathan Pryor  <jpryor@novell.com>

	* Check.cs: Add Check.SourceAndFunc().
	* Int32.cs: Obsolete Times(int,Action<int>), UpTo(int,int,Action<int>),
	  DownTo(int,int,Action<int>), Step(int,int,int,Action<int>), and replace
	  with overloads that don't take an Action<int> parameter but instead return
	  an IEnumerable<int> which can be used with
	  Apply<T>(IEnumerable<T>,Action<T>).
	* String.cs: Add `IEnumerable<string> Lines (string self)` and overloads.
	  Obsolete EachLine().
	* IEnumerable.cs: 
	  - Fix Repeat() so that it does the null check before .MoveNext() is 
	    called on the iterator.
	  - Add Apply(IEnumerable,Action) and Apply() methods to allow inserting
	    "side-effect" methods into an extension method "chain", e.g.
	      1.UpTo(5)
	        .Apply (Console.WriteLine)  // original
	        .Select (n => 2*n)          // multiply by 2
	        .Apply (Connsole.WriteLine) // final
	        .Apply ();                  // do it now, not later.
	  - It was pointed out that, to sort an IEnumerable<int> with 20million 
	    elements, adding them to a List<int> + sorting was faster than using
	    .OrderBy(n=>n) (~2s vs. 9s), so provide a Sort extension method for
	    simple sorting needs.
	  - Add `List<List<T>> ToList<T>(IEnumerable<IEnumerable<T>>) (to help with
	    testing Transpose(), below).
	  - Add slew of Haskell-inspired extension methods:
	    - (zip) .SelectFromEach<T1,T2,TR>(IEnumerable<T2>,Func<T1,T2,TR>)
	    - (init) .ExceptLast(), .ExceptLast(int)
	    - (intersperse) .Intersperse<TSource>(TSource)
	    - (intercalate) Intersperse<TSource>(IEnumerable<IEnumerable<TSource>>,IEnumerable<TSource>)
	    - (transpose) Transpose<TSource>(IEnumerable<IEnumerable<TSource>>)
	    - (foldr1) .AggregateReverse<T>(Func<T,T,T>)
	    - (foldr) .AggregateReverse<TS,TA>(TA,Func<TA,TS,TA>)
	    - .AggregateReverse<TS,TA,TR>(TA,Func<TA,TS,TA>,Func<TA,TR>)
	    - (concat) .Concat<TSource>(params IEnumerable<TSource>[])
	    - .Concat<TSource>(IEnumerable<IEnumerable<TSource>>)
	    - (and) And(IEnumerable<bool>)
	    - (or) Or(IEnumerable<bool>)
	    - (scanl1) .AggregateWithHistory<T>(Func<T,T,T>)
	    - (scanl) .AggregateWithHistory<TS,TA>(TA,Func<T,T,T>)
	    - .AggregateWithHistory<TS,TA,TR>(TA,Func<TA,TS,TA>, Func<TA,TR>)
	    - (scanr1) .AggregateReverseWithHistory<T>(Func<T,T,T>)
	    - (scanr) .AggregateReverseWithHistory<TS,TA>(TA,Func<TA,TS,TA>)
	    - .AggregateReverseWithHistory<TS,TA,TR>(TA,Func<TA,TS,TA>, Func<TA,TR>)

2007-11-17  Jb Evain  <jbevain@novell.com>

	* String.cs: Add ToEnum.

	* ICustomAttributeProvider.cs: Add generic versions of GetCustomAttributes
	and GetCustomAttribute.

2007-11-15  Sebastien Pouliot  <sebastien@ximian.com>

	* IEnumerable.cs: Replaced PathCombine with a version that reduce
	the number of validation and temporary string allocations.
